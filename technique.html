<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Technique Astro – Placidus PRO</title>
</head>

<body>

<h2>Calcul Placidus — Version PRO Exacte</h2>

<label>Latitude (ex : 46° 06' N) :</label><br>
<input id="lat" type="text" value="46° 06' N"><br><br>

<label>Longitude (ex : 0h 12m 48s E) :</label><br>
<input id="lon" type="text" value="0h 12m 48s E"><br><br>

<label>Date (AAAA-MM-JJ) :</label><br>
<input id="date" type="date" value="1962-01-29"><br><br>

<label>Heure légale (HH:MM) :</label><br>
<input id="time" type="time" value="19:30"><br><br>

<button onclick="runCalc()">Calculer</button>

<hr>

<h3>Diagnostics :</h3>
<pre id="debug">Aucun calcul.</pre>

<h3>Résultats :</h3>
<pre id="output">Aucun calcul.</pre>

<script>
/* ============================================
   BLOC 1 — FONCTIONS DE BASE (SÉCURISÉ)
   ============================================ */

/* Conversions */
function toRad(d) { return d * Math.PI / 180; }
function toDeg(r) { return r * 180 / Math.PI; }
function normalize(a) { a = a % 360; return a < 0 ? a + 360 : a; }

/* Format astrologique */
function dms(a) {
    const d = Math.floor(a);
    const m = Math.round((a - d) * 60);
    return `${d}°${m.toString().padStart(2,"0")}'`;
}

const SIGNS = [
    "♈ Bélier","♉ Taureau","♊ Gémeaux","♋ Cancer",
    "♌ Lion","♍ Vierge","♎ Balance","♏ Scorpion",
    "♐ Sagittaire","♑ Capricorne","♒ Verseau","♓ Poissons"
];
function signOf(a) { return SIGNS[Math.floor(a/30)]; }

/* Décode latitude type "46° 06' N" */
function parseLat(latStr) {
    const m = latStr.match(/(\d+)°\s+(\d+)'?\s*(N|S)/i);
    const deg = parseInt(m[1]);
    const min = parseInt(m[2]);
    const sign = (m[3].toUpperCase()==="N") ? 1 : -1;
    return sign * (deg + min/60);
}

/* Décode longitude type "0h 12m 48s E" en SECONDES */
function parseLongitude(lonStr) {
    const m = lonStr.match(/(\d+)h\s+(\d+)m\s+(\d+)s\s+(E|O)/i);
    const h = parseInt(m[1]);
    const mn = parseInt(m[2]);
    const s = parseInt(m[3]);
    const sign = (m[4].toUpperCase()==="E") ? 1 : -1;
    return sign * (h*3600 + mn*60 + s);
}

/* Convertit secondes → HH:MM:SS */
function secToHMS(sec) {
    sec = (sec % 86400 + 86400) % 86400;
    const h = Math.floor(sec/3600);
    const m = Math.floor((sec%3600)/60);
    const s = Math.floor(sec%60);
    return `${h.toString().padStart(2,"0")}:${m.toString().padStart(2,"0")}:${s.toString().padStart(2,"0")}`;
}
/* ============================================================
   BLOC 2 — UT, HEURE LOCALE, TEMPS SIDERAL (ASTROLOGIQUE)
   ============================================================ */

/* Décalage France (simple : -1 hiver / -2 été après 1976) */
function frenchOffset(dateObj) {
    const year = dateObj.getUTCFullYear();
    if (year < 1976) return -1;

    const m = dateObj.getUTCMonth()+1;
    if (m===6 || m===7 || m===8) return -2;
    return -1;
}

/* Convertit "HH:MM" en secondes */
function timeToSec(t) {
    const [h,m] = t.split(":").map(Number);
    return h*3600 + m*60;
}

/* TEMPS SIDERAL ASTROLOGIQUE EXACT (Meeus / Astrologue) */
function siderealTimeAstro(JD, localHours) {

    /* Formule astrologique classique :
       TS = TS0 + Heure locale + 3m56s * Heure locale
       TS0 = TS à 0h TU pour la date donnée
    */

    /* 1 — Temps sidéral à Greenwich à 0h */
    const T = (JD - 2451545.0) / 36525;

    let TS0 =
        100.46061837 +         // base
        36000.770053608 * T +  // dérive annuelle
        0.000387933 * T*T -    // correction
        (T*T*T)/38710000;      // correction fine

    TS0 = normalize(TS0);

    /* 2 — Ajout de l’heure locale (en heures → degrés) */
    const hourDeg = localHours * 15;  // 1h = 15°

    /* 3 — Correction astrologique 3m56s = 3.9333 min = 0.065555 h */
    const correction = localHours * 0.065555 * 15;

    /* Temps sidéral final */
    let LST = normalize(TS0 + hourDeg + correction);

    return { TS0: normalize(TS0), LST };
}

/* ============================================================
   FONCTION : prepareTimeData()
   Convertit :
   - Heure légale → UT
   - UT → heure locale
   - heure locale → TS0 + LST
   ============================================================ */

function prepareTimeData(dateStr, timeLegalStr, lonStr) {

    const dtLegal = new Date(`${dateStr}T${timeLegalStr}:00`);

    // 1 — Décalage horaire
    const offset = frenchOffset(dtLegal);

    // 2 — Heure légale → secondes
    const legalSec = timeToSec(timeLegalStr);

    // 3 — UT = heure légale + offset
    const utSec = legalSec + offset * 3600;
    const utHours = utSec / 3600;

    // 4 — Longitude en secondes → heure locale
    const lonSec = parseLongitude(lonStr);
    const localSec = utSec + lonSec;
    const localHours = localSec / 3600;

    // 5 — Calcul du JD
    const dtLocalISO = new Date(`${dateStr}T${secToHMS(localSec)}`);
    const JD = dtLocalISO.getTime()/86400000 + 2440587.5;

    // 6 — Temps sidéral astrologique
    const { TS0, LST } = siderealTimeAstro(JD, localHours);

    return {
        utSec,
        utHours,
        localSec,
        localHours,
        JD,
        TS0,
        LST
    };
}
/* ============================================================
   BLOC 3 — ASCENDANT & MILIEU DU CIEL EXACTS
   ============================================================ */

/* Obliquité moyenne (astrologie classique) */
function meanObliquity(JD) {
    const T = (JD - 2451545.0) / 36525;
    const seconds =
        21.448 -
        46.8150 * T -
        0.00059 * T*T +
        0.001813 * T*T*T;
    return toRad(23 + (26 + seconds/60)/60);
}

/* Calcule ASC & MC en degrés écliptiques */
function computeAngles(LSTdeg, latDeg, JD) {

    const ε = meanObliquity(JD);
    const φ = toRad(latDeg);
    const LST = toRad(LSTdeg);

    /* === MC ===
       MC = arctan( tan(LST) / cos(ε) )
       puis normalisation selon le quadrant
    */
    let MC = Math.atan2( Math.tan(LST), Math.cos(ε) );
    MC = normalize( toDeg(MC) );
    if (Math.cos(LST) < 0) MC = normalize(MC + 180);

    /* === ASCENDANT ===
       Formule professionnelle :
       asc = arctan2(
         -cos(ε)*tan(φ) - sin(ε)*sin(LST),
          cos(LST)
       )
    */
    let ASC = Math.atan2(
        -Math.cos(ε)*Math.tan(φ) - Math.sin(ε)*Math.sin(LST),
        Math.cos(LST)
    );
    ASC = normalize( toDeg(ASC) );

    return { ASC, MC };
}
console.log(
  prepareTimeData("1962-01-29", "19:30", "0h 12m 48s E") );
let t = prepareTimeData("1962-01-29", "19:30", "0h 12m 48s E");
console.log(
  computeAngles(t.LST, parseLat("46° 06' N"), t.JD)
);
/* ============================================================
   BLOC 4 — DEMI-ARCS PLACIDUS (ALGORITHME PROFESSIONNEL)
   ============================================================ */

/* Calcule la déclinaison à partir de la longitude écliptique */
function declination(lambdaRad, epsilon) {
    return Math.asin(Math.sin(lambdaRad) * Math.sin(epsilon));
}

/* Ascension droite à partir de longitude et déclinaison */
function rightAscension(lambdaRad, decRad, epsilon) {
    return Math.atan2(
        Math.sin(lambdaRad) * Math.cos(epsilon) - Math.tan(decRad) * Math.sin(epsilon),
        Math.cos(lambdaRad)
    );
}

/* Demi-arcs Placidus :
   HA = hour angle = angle horaire en radians
   Retourne l’ascension droite du point Placidus correspondant
*/
function placidusSemiArc(latRad, decRad, target) {

    /* Demi-arc diurne / nocturne */
    const term = -Math.tan(latRad) * Math.tan(decRad);

    /* Sécurité : si |term| >= 1 → latitude trop haute pour Placidus
       (mais ça n’arrive pas en France)
    */
    if (Math.abs(term) >= 1) return null;

    const semiArc = Math.acos(term); // en radians

    /* Les 4 maisons Placidus fondamentales :
        maison 11 : RA_MC + semiArc/3
        maison 12 : RA_MC + 2*semiArc/3
        maison 2  : RA_MH - 2*semiArc/3
        maison 3  : RA_MH - semiArc/3
    */

    if (target === 11) return  + semiArc / 3;
    if (target === 12) return  + 2 * semiArc / 3;
    if (target ===  2) return  - 2 * semiArc / 3;
    if (target ===  3) return  - semiArc / 3;

    return 0;
}

/* Calcule RA (ascension droite) d’un point Placidus en maison 11/12/2/3 :
   RA_house = RA_MC + offset   ou   RA_house = RA_MC + offset
*/
function placidusRA(RA_MC, latRad, dec_MC_Rad, target) {

    const offset = placidusSemiArc(latRad, dec_MC_Rad, target);
    if (offset === null) return null;

    return RA_MC + offset;  // RA en radians
}
// ==== TEST DU BLOC 4 ====

// Exemple : 29 janv 1962, 19h30, latitude 46°06'N
let t = prepareTimeData("1962-01-29", "19:30", "0h 12m 48s E");

// Obliquité
let eps = meanObliquity(t.JD);

// MC (déjà calculé via bloc 3)
let ang = computeAngles(t.LST, parseLat("46° 06' N"), t.JD);

// RA du MC (en radians)
let RA_MC = toRad(ang.MC);

// Déclinaison du MC
let decMC = declination(toRad(ang.MC), eps);

// Demi-arc pour maison 11
console.log("Offset maison 11 =", placidusSemiArc(toRad(parseLat("46° 06' N")), decMC, 11));
console.log("Offset maison 12 =", placidusSemiArc(toRad(parseLat("46° 06' N")), decMC, 12));
console.log("Offset maison 2  =", placidusSemiArc(toRad(parseLat("46° 06' N")), decMC,  2));
console.log("Offset maison 3  =", placidusSemiArc(toRad(parseLat("46° 06' N")), decMC,  3));

// RA de la maison 11
console.log("RA maison 11 =", placidusRA(RA_MC, toRad(parseLat("46° 06' N")), decMC, 11));

</script>

</body>
</html>

