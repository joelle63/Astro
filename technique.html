<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Technique Astro – Placidus PRO</title>
</head>

<body>

<h2>Calcul Placidus — Version PRO Exacte</h2>

<label>Latitude (ex : 46° 06' N) :</label><br>
<input id="lat" type="text" value="46° 06' N"><br><br>

<label>Longitude (ex : 0h 12m 48s E) :</label><br>
<input id="lon" type="text" value="0h 12m 48s E"><br><br>

<label>Date (AAAA-MM-JJ) :</label><br>
<input id="date" type="date" value="1962-01-29"><br><br>

<label>Heure légale (HH:MM) :</label><br>
<input id="time" type="time" value="19:30"><br><br>

<button onclick="runCalc()">Calculer</button>

<hr>

<h3>Diagnostics :</h3>
<pre id="debug">Aucun calcul.</pre>

<h3>Résultats :</h3>
<pre id="output">Aucun calcul.</pre>

<script>
/* =====================================================
   BLOC 1 — OUTILS DE BASE (obligatoire)
   ===================================================== */

// Convertit 0h 12m 48s E → secondes (+/-)
function parseLongitude(lon) {
    const m = lon.match(/(\d+)h (\d+)m (\d+)s (E|O)/);
    if (!m) return 0;
    let h = parseInt(m[1]);
    let mn = parseInt(m[2]);
    let s = parseInt(m[3]);
    let sec = h*3600 + mn*60 + s;
    if (m[4] === "O") sec = -sec;
    return sec;
}

// Convertit heure HH:MM → secondes
function timeToSeconds(t) {
    const [h, m] = t.split(":").map(x => parseInt(x));
    return h*3600 + m*60;
}

// Convertit secondes → HH:MM:SS
function secondsToHMS(sec) {
    sec = (sec % 86400 + 86400) % 86400;
    const h = Math.floor(sec/3600);
    const m = Math.floor((sec%3600)/60);
    const s = Math.floor(sec%60);
    return (
        String(h).padStart(2,"0") + ":" +
        String(m).padStart(2,"0") + ":" +
        String(s).padStart(2,"0")
    );
}

// Décalage France été/hiver
function frenchOffset(dateObj) {
    const y = dateObj.getUTCFullYear();
    if (y < 1976) return -1; // UTC+1 toute l'année
    const M = dateObj.getUTCMonth() + 1;
    if (M === 12 || M === 1 || M === 2 || M === 11) return -1; // hiver
    if (M === 6 || M === 7 || M === 8) return -2; // été
    return -1;
}

/* =====================================================
   BLOC 2 — RA / Decl depuis le Temps Sidéral Local
   ===================================================== */

function equatorialFromLST(lstDeg, obliquityDeg) {
    // LST = Temps sidéral local
    // obliquité de l’écliptique (≈ 23.44°)
    const lst = lstDeg * Math.PI/180;
    const eps = obliquityDeg * Math.PI/180;

    // RA = arctan ( tan(LST) / cos(eps) )
    const ra = Math.atan2(Math.tan(lst), Math.cos(eps)) * 180/Math.PI;

    // Decl = arcsin ( sin(eps) * sin(LST) )
    const dec = Math.asin(Math.sin(eps) * Math.sin(lst)) * 180/Math.PI;

    return { ra, dec };
}

/* ============================================================
   BLOC 3 — ASCENDANT & MILIEU DU CIEL EXACTS
   ============================================================ */

/* Obliquité moyenne (astrologie classique) */
function meanObliquity(JD) {
    const T = (JD - 2451545.0) / 36525;
    const seconds =
        21.448 -
        46.8150 * T -
        0.00059 * T*T +
        0.001813 * T*T*T;
    return toRad(23 + (26 + seconds/60)/60);
}

/* Calcule ASC & MC en degrés écliptiques */
function computeAngles(LSTdeg, latDeg, JD) {

    const ε = meanObliquity(JD);
    const φ = toRad(latDeg);
    const LST = toRad(LSTdeg);

    /* === MC ===
       MC = arctan( tan(LST) / cos(ε) )
       puis normalisation selon le quadrant
    */
    let MC = Math.atan2( Math.tan(LST), Math.cos(ε) );
    MC = normalize( toDeg(MC) );
    if (Math.cos(LST) < 0) MC = normalize(MC + 180);

    /* === ASCENDANT ===
       Formule professionnelle :
       asc = arctan2(
         -cos(ε)*tan(φ) - sin(ε)*sin(LST),
          cos(LST)
       )
    */
    let ASC = Math.atan2(
        -Math.cos(ε)*Math.tan(φ) - Math.sin(ε)*Math.sin(LST),
        Math.cos(LST)
    );
    ASC = normalize( toDeg(ASC) );

    return { ASC, MC };
}

/* ============================================================
   BLOC 4 — DEMI-ARCS PLACIDUS (ALGORITHME PROFESSIONNEL)
   ============================================================ */

/* Calcule la déclinaison à partir de la longitude écliptique */
function declination(lambdaRad, epsilon) {
    return Math.asin(Math.sin(lambdaRad) * Math.sin(epsilon));
}

/* Ascension droite à partir de longitude et déclinaison */
function rightAscension(lambdaRad, decRad, epsilon) {
    return Math.atan2(
        Math.sin(lambdaRad) * Math.cos(epsilon) - Math.tan(decRad) * Math.sin(epsilon),
        Math.cos(lambdaRad)
    );
}

/* Demi-arcs Placidus :
   HA = hour angle = angle horaire en radians
   Retourne l’ascension droite du point Placidus correspondant
*/
function placidusSemiArc(latRad, decRad, target) {

    /* Demi-arc diurne / nocturne */
    const term = -Math.tan(latRad) * Math.tan(decRad);

    /* Sécurité : si |term| >= 1 → latitude trop haute pour Placidus
       (mais ça n’arrive pas en France)
    */
    if (Math.abs(term) >= 1) return null;

    const semiArc = Math.acos(term); // en radians

    /* Les 4 maisons Placidus fondamentales :
        maison 11 : RA_MC + semiArc/3
        maison 12 : RA_MC + 2*semiArc/3
        maison 2  : RA_MH - 2*semiArc/3
        maison 3  : RA_MH - semiArc/3
    */

    if (target === 11) return  + semiArc / 3;
    if (target === 12) return  + 2 * semiArc / 3;
    if (target ===  2) return  - 2 * semiArc / 3;
    if (target ===  3) return  - semiArc / 3;

    return 0;
}

/* Calcule RA (ascension droite) d’un point Placidus en maison 11/12/2/3 :
   RA_house = RA_MC + offset   ou   RA_house = RA_MC + offset
*/
function placidusRA(RA_MC, latRad, dec_MC_Rad, target) {

    const offset = placidusSemiArc(latRad, dec_MC_Rad, target);
    if (offset === null) return null;

    return RA_MC + offset;  // RA en radians
}
/* =====================================================
   BLOC 5 — Conversion RA → Longitude zodiacale
   ===================================================== */

/* Transforme une Ascension Droite en longitude zodiacale
   en projetant sur l’écliptique.
   (approximation standard des tables Placidus) */
function zodiacFromRA(raDeg, latDeg) {
    const eps = 23.439291 * Math.PI / 180; // obliquité
    const ra  = raDeg  * Math.PI / 180;
    const lat = latDeg * Math.PI / 180;

    // Déclinaison fictive (projection simplifiée)
    const dec = Math.asin(Math.sin(lat) * Math.sin(ra));

    // Conversion équatoriale → écliptique
    const sinEcl = Math.sin(dec) * Math.cos(eps) - Math.cos(dec) * Math.sin(eps) * Math.sin(ra);
    const cosEcl = Math.cos(dec) * Math.cos(ra);

    const lon = Math.atan2(sinEcl, cosEcl) * 180 / Math.PI;
    const lonNorm = (lon % 360 + 360) % 360;

    return { lon: lonNorm };
}
/* ==========================================================
   TEST COMPLET DES BLOCS 1 → 5
   ========================================================== */

console.log("=== TEST BLOC 1 : PARSE / HEURE LOCALE ===");
console.log("parseLongitude =", parseLongitude("0h 12m 48s E"));
console.log("timeToSeconds =", timeToSeconds("19:30"));


console.log("=== TEST BLOC 2 : RA / Decl depuis LST ===");
const t2 = equatorialFromLST(48.0, 30.0);
console.log("RA =", t2.ra, "Dec =", t2.dec);


console.log("=== TEST BLOC 3 : EQ → EC ===");
const t3 = ecFromEquatorial(100, 10);
console.log("Zodiac =", t3.lon, "lat =", t3.lat);


console.log("=== TEST BLOC 4 : DEMI-ARCS ===");
const t4 = placidusOffsets(100, 46);
console.log("Offsets :", t4);


console.log("=== TEST BLOC 5 : RA → ZODIAC ===");
const t5 = zodiacFromRA(123, 46);
console.log("Résultat bloc 5 :", t5.lon);

</script>

</body>
</html>

