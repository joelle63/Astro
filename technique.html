<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Technique Astro – Placidus PRO</title>
</head>


<body>


<h2>Calcul Placidus — Version PRO Exacte</h2>


<label>Latitude (ex : 46° 06' N) :</label><br>
<input id="lat" type="text" value="46° 06' N"><br><br>


<label>Longitude (ex : 0h 12m 48s E) :</label><br>
<input id="lon" type="text" value="0h 12m 48s E"><br><br>


<label>Date (AAAA-MM-JJ) :</label><br>
<input id="date" type="date" value="1962-01-29"><br><br>


<label>Heure légale (HH:MM) :</label><br>
<input id="time" type="time" value="19:30"><br><br>


<button onclick="runCalc()">Calculer</button>


<hr>


<h3>Diagnostics :</h3>
<pre id="debug">Aucun calcul.</pre>


<h3>Résultats :</h3>
<pre id="output">Aucun calcul.</pre>


<script>
/* =====================================================
   BLOC 1 — OUTILS DE BASE (obligatoire)
   ===================================================== */


// Convertit 0h 12m 48s E → secondes (+/-)
function parseLongitude(lon) {
    const m = lon.match(/(\d+)h (\d+)m (\d+)s (E|O)/);
    if (!m) return 0;
    let h = parseInt(m[1]);
    let mn = parseInt(m[2]);
    let s = parseInt(m[3]);
    let sec = h*3600 + mn*60 + s;
    if (m[4] === "O") sec = -sec;
    return sec;
}


// Convertit heure HH:MM → secondes
function timeToSeconds(t) {
    const [h, m] = t.split(":").map(x => parseInt(x));
    return h*3600 + m*60;
}


// Convertit secondes → HH:MM:SS
function secondsToHMS(sec) {
    sec = (sec % 86400 + 86400) % 86400;
    const h = Math.floor(sec/3600);
    const m = Math.floor((sec%3600)/60);
    const s = Math.floor(sec%60);
    return (
        String(h).padStart(2,"0") + ":" +
        String(m).padStart(2,"0") + ":" +
        String(s).padStart(2,"0")
    );
}


// Décalage France été/hiver
function frenchOffset(dateObj) {
    const y = dateObj.getUTCFullYear();
    if (y < 1976) return -1; // UTC+1 toute l'année
    const M = dateObj.getUTCMonth() + 1;
    if (M === 12 || M === 1 || M === 2 || M === 11) return -1; // hiver
    if (M === 6 || M === 7 || M === 8) return -2; // été
    return -1;
}
/* =====================================================
   OUTILS TRIGONOMÉTRIQUES MANQUANTS
   ===================================================== */
function toRad(d) { return d * Math.PI / 180; }
function toDeg(r) { return r * 180 / Math.PI; }
function normalize(a) {
    a = a % 360;
    return a < 0 ? a + 360 : a;
}


/* =====================================================
   BLOC 2 — RA / Decl depuis le Temps Sidéral Local
   ===================================================== */


function equatorialFromLST(lstDeg, obliquityDeg) {
    // LST = Temps sidéral local
    // obliquité de l’écliptique (≈ 23.44°)
    const lst = lstDeg * Math.PI/180;
    const eps = obliquityDeg * Math.PI/180;


    // RA = arctan ( tan(LST) / cos(eps) )
    const ra = Math.atan2(Math.tan(lst), Math.cos(eps)) * 180/Math.PI;


    // Decl = arcsin ( sin(eps) * sin(LST) )
    const dec = Math.asin(Math.sin(eps) * Math.sin(lst)) * 180/Math.PI;


    return { ra, dec };
}


/* ============================================================
   BLOC 3 — ASCENDANT & MILIEU DU CIEL EXACTS
   ============================================================ */


/* Obliquité moyenne (astrologie classique) */
function meanObliquity(JD) {
    const T = (JD - 2451545.0) / 36525;
    const seconds =
        21.448 -
        46.8150 * T -
        0.00059 * T*T +
        0.001813 * T*T*T;
    return toRad(23 + (26 + seconds/60)/60);
}


/* Calcule ASC & MC en degrés écliptiques */
function computeAngles(LSTdeg, latDeg, JD) {


    const ε = meanObliquity(JD);
    const φ = toRad(latDeg);
    const LST = toRad(LSTdeg);


    /* === MC ===
       MC = arctan( tan(LST) / cos(ε) )
       puis normalisation selon le quadrant
    */
    let MC = Math.atan2( Math.tan(LST), Math.cos(ε) );
    MC = normalize( toDeg(MC) );
    if (Math.cos(LST) < 0) MC = normalize(MC + 180);


    /* === ASCENDANT ===
       Formule professionnelle :
       asc = arctan2(
         -cos(ε)*tan(φ) - sin(ε)*sin(LST),
          cos(LST)
       )
    */
    let ASC = Math.atan2(
        -Math.cos(ε)*Math.tan(φ) - Math.sin(ε)*Math.sin(LST),
        Math.cos(LST)
    );
    ASC = normalize( toDeg(ASC) );


    return { ASC, MC };
}


/* ============================================================
   BLOC 4 — DEMI-ARCS PLACIDUS (ALGORITHME PROFESSIONNEL)
   ============================================================ */


/* Calcule la déclinaison à partir de la longitude écliptique */
function declination(lambdaRad, epsilon) {
    return Math.asin(Math.sin(lambdaRad) * Math.sin(epsilon));
}


/* Ascension droite à partir de longitude et déclinaison */
function rightAscension(lambdaRad, decRad, epsilon) {
    return Math.atan2(
        Math.sin(lambdaRad) * Math.cos(epsilon) - Math.tan(decRad) * Math.sin(epsilon),
        Math.cos(lambdaRad)
    );
}


/* Demi-arcs Placidus :
   HA = hour angle = angle horaire en radians
   Retourne l’ascension droite du point Placidus correspondant
*/
function placidusSemiArc(latRad, decRad, target) {


    /* Demi-arc diurne / nocturne */
    const term = -Math.tan(latRad) * Math.tan(decRad);


    /* Sécurité : si |term| >= 1 → latitude trop haute pour Placidus
       (mais ça n’arrive pas en France)
    */
    if (Math.abs(term) >= 1) return null;


    const semiArc = Math.acos(term); // en radians


    /* Les 4 maisons Placidus fondamentales :
        maison 11 : RA_MC + semiArc/3
        maison 12 : RA_MC + 2*semiArc/3
        maison 2  : RA_MH - 2*semiArc/3
        maison 3  : RA_MH - semiArc/3
    */


    if (target === 11) return  + semiArc / 3;
    if (target === 12) return  + 2 * semiArc / 3;
    if (target ===  2) return  - 2 * semiArc / 3;
    if (target ===  3) return  - semiArc / 3;


    return 0;
}


/* Calcule RA (ascension droite) d’un point Placidus en maison 11/12/2/3 :
   RA_house = RA_MC + offset   ou   RA_house = RA_MC + offset
*/
function placidusRA(RA_MC, latRad, dec_MC_Rad, target) {


    const offset = placidusSemiArc(latRad, dec_MC_Rad, target);
    if (offset === null) return null;


    return RA_MC + offset;  // RA en radians
}
/* =====================================================
   BLOC 5 — Conversion RA → Longitude zodiacale
   ===================================================== */


/* Transforme une Ascension Droite en longitude zodiacale
   en projetant sur l’écliptique.
   (approximation standard des tables Placidus) */
function zodiacFromRA(raDeg, latDeg) {
    const eps = 23.439291 * Math.PI / 180; // obliquité
    const ra  = raDeg  * Math.PI / 180;
    const lat = latDeg * Math.PI / 180;


    // Déclinaison fictive (projection simplifiée)
    const dec = Math.asin(Math.sin(lat) * Math.sin(ra));


    // Conversion équatoriale → écliptique
    const sinEcl = Math.sin(dec) * Math.cos(eps) - Math.cos(dec) * Math.sin(eps) * Math.sin(ra);
    const cosEcl = Math.cos(dec) * Math.cos(ra);


    const lon = Math.atan2(sinEcl, cosEcl) * 180 / Math.PI;
    const lonNorm = (lon % 360 + 360) % 360;


    return { lon: lonNorm };
}
   /* ============================================================
   BLOC 6 — CALCUL DES 4 MAISONS PLACIDUS (11, 12, 2, 3)
   ============================================================ */


/* Renvoie un objet contenant les cuspides Placidus exactes 
   en degrés zodiacaux normalisés (0–359) pour :
   11, 12, 2, 3
*/
function computePlacidusHouses(RA_MC_deg, latDeg, dec_MC_deg) {


    // Conversion en radians
    const RA_MC = RA_MC_deg * Math.PI / 180;
    const latRad = latDeg * Math.PI / 180;
    const decRad = dec_MC_deg * Math.PI / 180;


    // Obliquité en radians (utilisée par le bloc 5 au besoin)
    const eps = 23.439291 * Math.PI / 180;


    // Résultat
    let res = {};


    // Liste des maisons à calculer
    const list = [11, 12, 2, 3];


    for (let h of list) {


        // Ascension droite Placidus en radians
        const raPl = placidusRA(RA_MC, latRad, decRad, h);
        if (raPl === null) {
            res[h] = null;
            continue;
        }


        // Convertir cette RA en degrés
        const raDeg = (raPl * 180 / Math.PI + 360) % 360;


        // Convertir RA → longitude zodiacale
        const z = zodiacFromRA(raDeg, latDeg);


        res[h] = {
            ra: raDeg,
            lon: z.lon
        };
    }


    return res;
}
/* ============================================================
   BLOC 7 — CHAÎNE COMPLÈTE ASC / MC / MAISONS PLACIDUS
   ============================================================ */


function computeFullChart(latStr, lonStr, dateStr, timeStr) {
/* ============================================================
   BLOC 8 — AFFICHAGE DES RÉSULTATS
   ============================================================ */


function displayResult(res) {
    if (res.error) {
        document.getElementById("output").textContent = "ERREUR : " + res.error;
        return;
    }


    let txt = "";


    txt += "=== HEURES ===\n";
    txt += "Heure légale : " + res.heures.heure_legale + "\n";
    txt += "UT           : " + res.heures.UT + "\n";
    txt += "Locale       : " + res.heures.locale + "\n";
    txt += "LST (°)      : " + res.heures.LST_deg.toFixed(4) + "\n\n";


    txt += "=== ANGLES ===\n";
    txt += "Ascendant : " + res.angles.asc_deg.toFixed(4) + "°  (zodiac " + res.angles.asc_sign.toFixed(2) + "°)\n";
    txt += "Milieu du Ciel : " + res.angles.mc_deg.toFixed(4) + "° (zodiac " + res.angles.mc_sign.toFixed(2) + "°)\n\n";


    txt += "=== MAISONS PLACIDUS ===\n";
    for (let h of [11, 12, 2, 3]) {
        const M = res.maisons[h];
        if (!M) {
            txt += "Maison " + h + " : impossible\n";
        } else {
            txt += "Maison " + h + " : RA = " +
                M.ra.toFixed(4) + "°,  Long = " +
                M.lon.toFixed(4) + "°\n";
        }
    }


    document.getElementById("output").textContent = txt;
}


/* Fonction appelée par le bouton */
function runCalc() {
    const result = computeFullChart(
        document.getElementById("lat").value,
        document.getElementById("lon").value,
        document.getElementById("date").value,
        document.getElementById("time").value
    );


    displayResult(result);
}


    /* ------------------------------
       1. PARSE COORDONNÉES
       ------------------------------ */
    const latMatch = latStr.match(/(\d+)° (\d+)' (N|S)/);
    if (!latMatch) return { error: "Latitude invalide" };


    const latDeg =
        parseInt(latMatch[1]) +
        parseInt(latMatch[2]) / 60;


    const latFinal = latMatch[3] === "S" ? -latDeg : latDeg;


    const lonSeconds = parseLongitude(lonStr); // déjà validé bloc 1
    const lonDeg = lonSeconds / 240;           // 360°/24h → 15°/h → 240s = 1°


    /* ------------------------------
       2. HEURE LOCALE
       ------------------------------ */
    const dateObj = new Date(`${dateStr}T${timeStr}:00`);
    const offset = frenchOffset(dateObj);
    const legalSec = timeToSeconds(timeStr);
    const UT_sec = legalSec + offset*3600;
    const local_sec = UT_sec + lonSeconds;
    const timeLocal = secondsToHMS(local_sec);


    /* ------------------------------
       3. TEMPS SIDÉRAL LOCAL (LST)
       ------------------------------ */
    const dtLocal = new Date(`${dateStr}T${timeLocal}`);
    const JD = dtLocal.getTime()/86400000 + 2440587.5;
    const T = (JD - 2451545.0) / 36525;


    let GMST =
        280.46061837 +
        360.98564736629*(JD - 2451545) +
        0.000387933*T*T -
        (T*T*T)/38710000;


    GMST = ((GMST % 360) + 360) % 360;


    const LST = ((GMST + lonDeg) % 360 + 360) % 360;


    /* ------------------------------
       4. CALCUL ASC / MC — BLOC 3
       ------------------------------ */
    const { ASC, MC } = computeAngles(LST, latFinal, JD);


    /* ------------------------------
       5. RA / Decl du MC — BLOC 2
       ------------------------------ */
    const eq = equatorialFromLST(MC, 23.439291);
    const RA_MC = eq.ra;
    const dec_MC = eq.dec;


    /* ------------------------------
       6. MAISONS PLACIDUS — BLOC 6
       ------------------------------ */
    const plac = computePlacidusHouses(RA_MC, latFinal, dec_MC);


    /* ------------------------------
       7. ASSEMBLAGE DU RÉSULTAT
       ------------------------------ */
   const full = {
    heures: {
        heure_legale: timeStr,
        UT: secondsToHMS(UT_sec),
        locale: timeLocal,
        LST_deg: LST
    },

angles: {
    asc_deg: ASC,
    asc_zodiac: formatZodiac(ASC),
    mc_deg: MC,
    mc_zodiac: formatZodiac(MC)
},

    maisons: {
    1: formatZodiac(ASC),
    10: formatZodiac(MC),
    2: plac[2] ? formatZodiac(plac[2].lon) : null,
    3: plac[3] ? formatZodiac(plac[3].lon) : null,
    5: plac[5] ? formatZodiac(plac[5].lon) : null,
    6: plac[6] ? formatZodiac(plac[6].lon) : null
}

};


// *** AJOUT IMPORTANT ***
displayResult(full);

return full;

}
/* =====================================================
   OUTIL — Convertit 0–359° en "dd°mm Signe"
   ===================================================== */

function formatZodiac(deg) {
    const signs = [
        "Bélier", "Taureau", "Gémeaux", "Cancer",
        "Lion", "Vierge", "Balance", "Scorpion",
        "Sagittaire", "Capricorne", "Verseau", "Poissons"
    ];

    deg = ((deg % 360) + 360) % 360;

    const signIndex = Math.floor(deg / 30);
    const sign = signs[signIndex];

    const withinSign = deg - signIndex * 30;
    const d = Math.floor(withinSign);
    const m = Math.round((withinSign - d) * 60);

    return `${d}°${String(m).padStart(2,"0")} ${sign}`;
}


/* ==========================================================
   TEST COMPLET DES BLOCS 1 → 5
   ========================================================== */


console.log("=== TEST BLOC 1 : PARSE / HEURE LOCALE ===");
console.log("parseLongitude =", parseLongitude("0h 12m 48s E"));
console.log("timeToSeconds =", timeToSeconds("19:30"));


console.log("=== TEST BLOC 2 : RA / Decl depuis LST ===");
const t2 = equatorialFromLST(48.0, 30.0);
console.log("RA =", t2.ra, "Dec =", t2.dec);


console.log("=== TEST BLOC 5 : RA → ZODIAC ===");
const t5 = zodiacFromRA(123, 46);
console.log("Résultat bloc 5 :", t5.lon);


console.log("=== TEST BLOC 6 : CUSP PLACIDUS (11-12-2-3) ===");


// Exemple arbitraire de test (RA_MC, latitude, declinaison du MC)
const t6 = computePlacidusHouses(100, 46, 20);


console.log("Maisons Placidus :", t6);

console.log("=== TEST BLOC 7 : FULL CHART ===");
const t7 = computeFullChart(
    "46° 06' N",
    "0h 12m 48s E",
    "1962-01-29",
    "19:30"
);
console.log(t7);
console.log("=== FORMAT ASTROLOGIQUE (ASC / MC / MAISONS) ===");

console.log("Ascendant :", formatZodiac(t7.angles.asc_deg));
console.log("Milieu du Ciel :", formatZodiac(t7.angles.mc_deg));

if (t7.maisons[2]) {
    console.log("Maison 2 :", formatZodiac(t7.maisons[2].lon));
}
if (t7.maisons[3]) {
    console.log("Maison 3 :", formatZodiac(t7.maisons[3].lon));
}
if (t7.maisons[5]) {
    console.log("Maison 5 :", formatZodiac(t7.maisons[5].lon));
}
if (t7.maisons[6]) {
    console.log("Maison 6 :", formatZodiac(t7.maisons[6].lon));
}

</script>


</body>
</html>
