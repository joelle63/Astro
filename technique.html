<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Technique Astro</title>
</head>

<body>

<h2>Calcul Placidus — Technique</h2>

<label>Latitude :</label><br>
<input id="lat" type="text" value="46° 06' N"><br><br>

<label>Longitude :</label><br>
<input id="lon" type="text" value="0h 12m 48s E"><br><br>

<label>Date :</label><br>
<input id="date" type="date" value="1962-01-29"><br><br>

<label>Heure légale :</label><br>
<input id="time" type="time" value="19:30"><br><br>

<button onclick="runCalc()">Calculer</button>

<hr>

<h3>Diagnostics :</h3>
<pre id="debug">Aucun calcul.</pre>

<h3>Résultats :</h3>
<pre id="output">Aucun calcul.</pre>

<script>
/* =====================================================
   1. OUTILS BASIC : Heures, longitudes, offsets
===================================================== */

// Convertit "0h 12m 48s E" → secondes (+/-)
function parseLongitude(lon) {
    const m = lon.match(/(\d+)h (\d+)m (\d+)s (E|O)/);
    if (!m) return 0;
    let h = +m[1], mn = +m[2], s = +m[3];
    let sec = h*3600 + mn*60 + s;
    if (m[4] === "O") sec = -sec;
    return sec;
}

// Décalage France GMT
function frenchOffset(dateObj) {
    const year = dateObj.getUTCFullYear();
    if (year < 1976) return -1; // avant 1976 = UTC+1 toute l'année
    const m = dateObj.getUTCMonth()+1;
    if ([11,12,1,2].includes(m)) return -1; // hiver
    if ([6,7,8].includes(m)) return -2;     // été
    return -1; // mi-saison
}

function timeToSeconds(t) {
    const [H,M] = t.split(":").map(x=>parseInt(x));
    return H*3600 + M*60;
}

function secondsToHMS(sec) {
    sec = (sec % 86400 + 86400) % 86400;
    const h = Math.floor(sec/3600);
    const m = Math.floor((sec%3600)/60);
    const s = Math.floor(sec%60);
    return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
}

/* =====================================================
   2. TEMPS SIDÉRAL ASTROLOGIQUE — FORMULE STANDARD
===================================================== */

// Temps sidéral (GMST) avec la formule astrologique traditionnelle
// DONNE TS0 = 08:31:03 pour 1962-01-29
function gmstAstrologique(JD_ut, ut_seconds) {

    // JD à minuit UT
    const JD0 = Math.floor(JD_ut - 0.5) + 0.5;

    const T = (JD0 - 2451545.0) / 36525;

    // GMST à 0h UT (en SECONDES)
    let GMST0 =
        24110.54841 +
        8640184.812866 * T +
        0.093104 * T*T -
        0.0000062 * T*T*T;

    // GMST à l'heure UT
    let GMST = GMST0 + 1.00273790935 * ut_seconds;

    GMST = (GMST % 86400 + 86400) % 86400;

    return {GMST, GMST0, JD0};
}

/* =====================================================
   3. CALCUL COMPLET : ASC, MC, MAISONS
===================================================== */

function computeChart({lat, lon, date, timeLocal, ut_seconds}) {

    function toRad(d){return d*Math.PI/180;}
    function toDeg(r){return r*180/Math.PI;}
    function norm(a){a=a%360;return a<0?a+360:a;}

    const signs=["♈ Bélier","♉ Taureau","♊ Gémeaux","♋ Cancer","♌ Lion","♍ Vierge",
                 "♎ Balance","♏ Scorpion","♐ Sagittaire","♑ Capricorne","♒ Verseau","♓ Poissons"];

    function signOf(a){return signs[Math.floor(a/30)];}

    // Latitude
    const latM = lat.match(/(\d+)° (\d+)' (N|S)/);
    const φ = (latM[3]=="N"?1:-1)*(+latM[1] + (+latM[2]/60));
    const φr = toRad(φ);

    // Date & JD
    const dt = new Date(`${date}T${timeLocal}`);
    const JD = dt.getTime()/86400000 + 2440587.5;

    // GMST + TS0
    const {GMST, GMST0, JD0} = gmstAstrologique(JD, ut_seconds);

    // Longitude (sec) & LST
    const lon_sec = parseLongitude(lon);
    const LST_sec = (GMST + lon_sec + 86400) % 86400;
    const LST = (LST_sec/86400)*360;

    // Obliquité
    const eps = toRad(23.439291);

    // MC
    let MC_rad = Math.atan2( Math.tan(toRad(LST)), Math.cos(eps) );
    let MC = norm(toDeg(MC_rad));
    if (Math.cos(toRad(LST)) < 0) MC = norm(MC+180);

    // ASC
    const asc_rad =
        Math.atan2(
            -Math.cos(eps)*Math.tan(φr) - Math.sin(eps)*Math.sin(toRad(LST)),
            Math.cos(toRad(LST))
        );
    const ASC = norm(toDeg(asc_rad));

    // Placidus (encore la version simplifiée tant que tu n'as pas le “pro”)
    function placidusHouse(n){
        let base =
            n==2 ? LST+30 :
            n==3 ? LST+60 :
            n==5 ? LST+120 :
                   LST+150;
        base = norm(base);
        let H = toRad(base), prev;
        for(let i=0;i<15;i++){
            prev = H;
            H = Math.atan2(
                Math.sin(prev),
                Math.cos(prev)*Math.cos(eps) - Math.tan(φr)*Math.sin(eps)
            );
            if(Math.abs(H-prev)<1e-7) break;
        }
        return norm(toDeg(H));
    }

    function pack(v){
        const d=Math.floor(v);
        const m=Math.round((v-d)*60);
        return `${d}°${String(m).padStart(2,"0")}'`;
    }

    return {
        JD,
        JD0,
        TS0: secondsToHMS(GMST0),     // Temps sidéral à minuit (TS₀)
        GMST: secondsToHMS(GMST),     // Temps sidéral de Greenwich (au moment UT)
        LST: secondsToHMS(LST_sec),   // Temps sidéral local (ASC & maisons)
        asc:{deg:ASC,txt:pack(ASC),sign:signOf(ASC)},
        mc:{deg:MC,txt:pack(MC),sign:signOf(MC)},
        h2:{deg:placidusHouse(2),txt:pack(placidusHouse(2)),sign:signOf(placidusHouse(2))},
        h3:{deg:placidusHouse(3),txt:pack(placidusHouse(3)),sign:signOf(placidusHouse(3))},
        h5:{deg:placidusHouse(5),txt:pack(placidusHouse(5)),sign:signOf(placidusHouse(5))},
        h6:{deg:placidusHouse(6),txt:pack(placidusHouse(6)),sign:signOf(placidusHouse(6))}
    };
}

/* =====================================================
   4. APPEL FINAL + DEBUG
===================================================== */

function runCalc(){
    const lat=document.getElementById("lat").value;
    const lon=document.getElementById("lon").value;
    const date=document.getElementById("date").value;
    const timeLegal=document.getElementById("time").value;

    // Heure légale → UT → locale
    const dtL = new Date(`${date}T${timeLegal}:00`);
    const offset = frenchOffset(dtL);
    const legal = timeToSeconds(timeLegal);
    const ut_seconds = legal + offset*3600;
    const lon_seconds = parseLongitude(lon);
    const local_seconds = ut_seconds + lon_seconds;

    const timeLocal = secondsToHMS(local_seconds);

    const r = computeChart({
        lat, lon, date, timeLocal, ut_seconds
    });

    // DEBUG COMPLET
    const debug =
`Heure légale : ${timeLegal}
Heure GMT (UT) : ${secondsToHMS(ut_seconds)}
Longitude : ${secondsToHMS(lon_seconds)}
Heure locale : ${timeLocal}

TS à minuit (TS0) : ${r.TS0}
Temps sidéral Greenwich (GMST instantané) : ${r.GMST}
Temps sidéral local (LST) : ${r.LST}
`;

    document.getElementById("debug").textContent = debug;
    document.getElementById("output").textContent = JSON.stringify(r, null, 2);
}

</script>

</body>
</html>
